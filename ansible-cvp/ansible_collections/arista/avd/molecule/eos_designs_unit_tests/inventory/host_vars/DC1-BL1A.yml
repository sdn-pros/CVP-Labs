---
my_special_dci_ethernet_interfaces:
  Ethernet4000:
    ip_address: 10.3.2.1/21

custom_structured_configuration_list_merge: append

# Test appending to list of name-servers.
override_name_server:
  nodes:
# - 192.168.200.5 <- Existing entry generated by eos_designs
# - 8.8.8.8       <- Existing entry generated by eos_designs
  - 1.1.1.1

# Testing empty key
cvp_ingestauth_key: ""

# Testing overlay loopback description override
overlay_loopback_description: "MY_OVERLAY_LOOPBACK"

vtep_vvtep_ip: 192.168.255.255/32

# Testing event_handlers
event_handlers:
  evpn-blacklist-recovery:
    action_type: bash
    action: FastCli -p 15 -c "clear bgp evpn host-flap"
    delay: 300
    trigger: on-logging
    regex: EVPN-3-BLACKLISTED_DUPLICATE_MAC
    asynchronous: true

# Testing with inline jinja - targeting base.py loaded in yaml_templates_to_facts.
# Since base.py is not performing any templating, the vars must be templated before handed over to the python class.
template_timezone: "correctly_templated_timezone"
timezone: "{{ template_timezone }}"

# Test Mac address table variables
mac_address_table:
  aging_time: 42

# Testing custom_structured_configuration setting a dict key from inline jinja with switch.x facts.
# Rare customer use case, but known to be in the field, so we should make sure this does not break.
#
# Unless switch.x is available in hostvars when yaml_templates_to_facts run, this will _overwrite_ the
# dict (aging_time: 42 will disappear), since the unresolved jinja will be seen as a string,
# so combine is not possible.
#
# TODO: Refactor custom_structured_configuration_ to Python and load switch facts from avd_switch_facts
# _before_ performing input data templating. Then we can remove switch facts from global vars
my_mac_address_table:
  notification_host_flap:
    logging: "{{ switch.id == 6 }}"

override_mac_address_table: "{{ my_mac_address_table }}"
